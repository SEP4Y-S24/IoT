# Secure Messaging Protocol

This protocol is designed for encrypting and decrypting messages using AES-128-cbc, with key exchange facilitated through elliptic curve encryption.

## Key Exchange

When a clock connects to a server, both Clock and Server generate their private and public keys using ECC [secp256r1](https://www.nervos.org/knowledge-base/what_is_secp256r1). Clock sends its public key to the server in a message with the action type **CK** (Clock Key) and waits to receive a public key from the server in a message **SK** (Server Key). The public keys are 64 bytes long.

### Example of message
 
_CK|64|1FF601B55B0C7499EE6FADA40DFFAE60477F1A1EFC55A8EDBD4A2850C71E6571A00CFF26602ADEC9F37207509D04839B79BA153001019F8B3A28B9030B986552|_


Once both entities receive public keys from each other, they can combine their private key with the received public key to generate a shared secret. The shared secret will be the same on both sides. After that, the shared secret has to be hashed using sha-128. The resulting hash needs to be truncated. Only the first 16 bytes of the hash are used as a key for symmetric encryption.

## Encryption and Decryption

All messages sent after key exchange have to be encrypted using AES-128-cbc. CBC requires a 16 bytes long initialization vector (IV) to encrypt and decrypt a message (IV must be unique for every message). The IV has to be randomly generated by the entity that sends a message. The IV used to encrypt the message has to be added at the beginning of the encrypted text and sent with it. Therefore, the receiver of the message can extract the IV (by getting the first 16 bytes of the received data) and use it to decrypt the message.

| 16 bytes - IV | Encrypted message(as big as it is needed) |
| --- | --- |
| 4ba9d716fa5b6237 | 03ef395748a4004b199ffbc059d9a7dfc68b5af8 |
